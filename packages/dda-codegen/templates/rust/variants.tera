// AUTO-GENERATED from DDA_SPEC.yaml
// DO NOT EDIT - Changes will be overwritten
//
// Generated at: {{ timestamp }}
// Spec version: {{ metadata.spec_version }}
// Generator: dda-codegen v0.1.0

/// DDA Variant Metadata
///
/// Defines properties and behavior for each DDA analysis variant.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VariantMetadata {
    /// Variant abbreviation (e.g., "ST", "CT", "CD")
    pub abbreviation: &'static str,

    /// Full variant name
    pub name: &'static str,

    /// Detailed description
    pub description: &'static str,

    /// Output file suffix appended by binary
    pub output_suffix: &'static str,

    /// Column stride for parsing output
    /// - ST/CT/DE: 4 columns per channel/pair
    /// - CD: 2 columns per directed pair
    /// - SY: 1 column per channel
    pub stride: u32,

    /// Whether this variant requires CT window parameters
    pub requires_ct_params: bool,
}

impl VariantMetadata {
    /// Get variant metadata by abbreviation
    pub fn from_abbrev(abbrev: &str) -> Option<&'static Self> {
        VARIANT_REGISTRY.iter().find(|v| v.abbreviation == abbrev)
    }

    /// Get variant metadata by output suffix
    pub fn from_suffix(suffix: &str) -> Option<&'static Self> {
        VARIANT_REGISTRY.iter().find(|v| v.output_suffix == suffix)
    }
}

/// Registry of all DDA variants
///
/// This is the canonical list of all supported DDA analysis variants.
/// Order matches SELECT mask bit positions (skipping RESERVED at position 3).
pub const VARIANT_REGISTRY: &[VariantMetadata] = &[
{%- for entry in sorted_variants %}
    VariantMetadata {
        abbreviation: "{{ entry.abbrev }}",
        name: "{{ entry.variant.name }}",
        description: "{{ entry.variant.description }}",
        output_suffix: "{{ entry.variant.output_suffix }}",
        stride: {{ entry.variant.stride }},
        requires_ct_params: {% if entry.variant.required_params | length > 0 %}true{% else %}false{% endif %},
    },
{%- endfor %}
];

/// SELECT mask bit positions
///
/// The SELECT mask is a 6-bit array controlling which variants to execute.
/// Format: ST CT CD RESERVED DE SY
pub mod select_mask_positions {
{%- for entry in sorted_variants %}
    {%- if entry.abbrev == "ST" %}
    pub const {{ entry.abbrev }}: usize = 0;
    {%- elif entry.abbrev == "CT" %}
    pub const {{ entry.abbrev }}: usize = 1;
    {%- elif entry.abbrev == "CD" %}
    pub const {{ entry.abbrev }}: usize = 2;
    {%- elif entry.abbrev == "DE" %}
    pub const {{ entry.abbrev }}: usize = 4; // Position 3 is RESERVED
    {%- elif entry.abbrev == "SY" %}
    pub const {{ entry.abbrev }}: usize = 5;
    {%- endif %}
{%- endfor %}
    pub const RESERVED: usize = 3;
}

/// Generate SELECT mask from enabled variants
///
/// # Arguments
/// * `variants` - List of variant abbreviations to enable (e.g., &["ST", "CT"])
///
/// # Returns
/// 6-element array with 1s for enabled variants, 0s for disabled
///
/// # Example
/// ```
/// use dda_rs::generated::variants::*;
/// let mask = generate_select_mask(&["ST", "SY"]);
/// assert_eq!(mask, [1, 0, 0, 0, 0, 1]); // ST and SY enabled
/// ```
pub fn generate_select_mask(variants: &[&str]) -> [u8; 6] {
    let mut mask = [0; 6];

    for variant in variants {
        match *variant {
{%- for entry in sorted_variants %}
            "{{ entry.abbrev }}" => mask[select_mask_positions::{{ entry.abbrev }}] = 1,
{%- endfor %}
            _ => log::warn!("Unknown variant: {}", variant),
        }
    }

    mask
}

/// Parse SELECT mask to list of enabled variants
///
/// # Arguments
/// * `mask` - 6-element SELECT mask array
///
/// # Returns
/// Vector of enabled variant abbreviations
///
/// # Example
/// ```
/// use dda_rs::generated::variants::*;
/// let mask = [1, 0, 0, 0, 0, 1];
/// let enabled = parse_select_mask(&mask);
/// assert_eq!(enabled, vec!["ST", "SY"]);
/// ```
pub fn parse_select_mask(mask: &[u8]) -> Vec<&'static str> {
    let mut enabled = Vec::new();

    if mask.len() < 6 {
        log::error!("Invalid SELECT mask: expected 6 bits, got {}", mask.len());
        return enabled;
    }

{%- for entry in sorted_variants %}
    if mask[select_mask_positions::{{ entry.abbrev }}] == 1 {
        enabled.push("{{ entry.abbrev }}");
    }
{%- endfor %}

    enabled
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_variant_registry_size() {
        // Should have all variants except RESERVED
        assert_eq!(VARIANT_REGISTRY.len(), {{ sorted_variants | length }});
    }

    #[test]
    fn test_variant_lookup_by_abbrev() {
{%- for entry in sorted_variants %}
        let variant = VariantMetadata::from_abbrev("{{ entry.abbrev }}");
        assert!(variant.is_some());
        assert_eq!(variant.unwrap().name, "{{ entry.variant.name }}");
        assert_eq!(variant.unwrap().stride, {{ entry.variant.stride }});
{%- endfor %}
    }

    #[test]
    fn test_variant_lookup_by_suffix() {
{%- for entry in sorted_variants %}
        let variant = VariantMetadata::from_suffix("{{ entry.variant.output_suffix }}");
        assert!(variant.is_some());
        assert_eq!(variant.unwrap().abbreviation, "{{ entry.abbrev }}");
{%- endfor %}
    }

    #[test]
    fn test_select_mask_generation() {
        let mask = generate_select_mask(&["ST", "SY"]);
        assert_eq!(mask[select_mask_positions::ST], 1);
        assert_eq!(mask[select_mask_positions::CT], 0);
        assert_eq!(mask[select_mask_positions::CD], 0);
        assert_eq!(mask[select_mask_positions::RESERVED], 0);
        assert_eq!(mask[select_mask_positions::DE], 0);
        assert_eq!(mask[select_mask_positions::SY], 1);
    }

    #[test]
    fn test_select_mask_parsing() {
        let mask = [1, 0, 0, 0, 0, 1];
        let enabled = parse_select_mask(&mask);
        assert_eq!(enabled, vec!["ST", "SY"]);
    }

    #[test]
    fn test_cd_only_mask() {
        // CD now works independently
        let mask = generate_select_mask(&["CD"]);
        assert_eq!(mask[select_mask_positions::CD], 1);
        assert_eq!(mask[select_mask_positions::ST], 0);
        assert_eq!(mask[select_mask_positions::CT], 0);
    }
}
