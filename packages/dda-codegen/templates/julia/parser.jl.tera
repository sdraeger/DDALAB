# AUTO-GENERATED from DDA_SPEC.yaml
# DO NOT EDIT - Changes will be overwritten
#
# Generated at: {{ timestamp }}
# Spec version: {{ metadata.spec_version }}
# Generator: dda-codegen v0.1.0

"""
DDA Output Parser

Provides functions for parsing DDA binary output files into structured format.
"""

"""
Structured timepoint data containing window bounds, coefficients, and error
"""
struct Timepoint
    window_start::Int
    window_end::Int
    coefficients::Vector{Float64}
    error::Float64
end

"""
Structured channel/pair data containing all timepoints
"""
struct ChannelData
    channel_index::Int
    timepoints::Vector{Timepoint}
end

"""
Structured DDA output preserving all values
"""
struct StructuredDDAOutput
    channels::Vector{ChannelData}
end

"""
    parse_dda_output_structured(content::String, stride::Int) -> StructuredDDAOutput

Parse DDA output file into structured format preserving all values.

# Arguments
- `content`: File content as string
- `stride`: Column stride for this variant (number of values per channel/pair)

# Returns
Structured output with all coefficients and error values preserved

# Format
Each row in the output contains:
- window_start window_end [data for all channels/pairs]
- Data is grouped by stride (e.g., stride=4 means groups of 4 values)
- Each stride group represents one channel/pair's data
- Within each group: first (stride-1) values are coefficients, last value is error

For example, with stride=4 (ST/CT/DE variants):
- Values 0-2: coefficients (a_1, a_2, a_3)
- Value 3: error
"""
function parse_dda_output_structured(content::String, stride::Int)::StructuredDDAOutput
    lines = split(content, '\n')
    raw_data = Vector{Vector{Float64}}()

    # Read all lines, skip comments and empty lines
    for line in lines
        line_stripped = strip(line)

        if isempty(line_stripped) || startswith(line_stripped, '#')
            continue
        end

        values = Float64[]
        for token in split(line_stripped)
            try
                val = parse(Float64, token)
                if isfinite(val)
                    push!(values, val)
                end
            catch
                continue
            end
        end

        if !isempty(values)
            push!(raw_data, values)
        end
    end

    if isempty(raw_data)
        return StructuredDDAOutput(ChannelData[])
    end

    # Determine number of channels/pairs from row length
    # Format: window_start window_end [stride values per channel] * num_channels
    first_row = raw_data[1]
    data_columns = length(first_row) - 2  # Exclude window bounds

    if data_columns % stride != 0
        error("Invalid data format: $data_columns data columns is not divisible by stride $stride")
    end

    num_channels = div(data_columns, stride)

    # Build structured output
    channels = ChannelData[]

    for channel_idx in 1:num_channels
        timepoints = Timepoint[]

        for row in raw_data
            window_start = Int(row[1])
            window_end = Int(row[2])

            # Extract values for this channel/pair
            # Start at column 3 (skip window bounds), then offset by (channel_idx-1) * stride
            start_col = 3 + (channel_idx - 1) * stride
            end_col = start_col + stride - 1
            channel_values = row[start_col:end_col]

            # Split into coefficients and error
            # Last value in the stride group is the error
            if length(channel_values) >= 2
                coefficients = channel_values[1:end-1]
                error = channel_values[end]
            elseif length(channel_values) == 1
                # For stride=1 (like SY), the single value is the error
                coefficients = Float64[]
                error = channel_values[1]
            else
                coefficients = Float64[]
                error = 0.0
            end

            push!(timepoints, Timepoint(window_start, window_end, coefficients, error))
        end

        push!(channels, ChannelData(channel_idx, timepoints))
    end

    return StructuredDDAOutput(channels)
end

"""
    parse_dda_output(content::String, column_stride::Int=4) -> Matrix{Float64}

Parse DDA output file (legacy format for backward compatibility).

# Arguments
- `content`: File content as string
- `column_stride`: Column stride for this variant

# Returns
2D matrix [channels/pairs × timepoints]

# Note
This method only extracts the first value (coefficient) from each stride group.
Use `parse_dda_output_structured()` to get all values including error.
"""
function parse_dda_output(content::String, column_stride::Int=4)::Matrix{Float64}
    lines = split(content, '\n')
    matrix = Vector{Vector{Float64}}()

    for line in lines
        line_stripped = strip(line)

        if isempty(line_stripped) || startswith(line_stripped, '#')
            continue
        end

        values = Float64[]
        for token in split(line_stripped)
            try
                val = parse(Float64, token)
                if isfinite(val)
                    push!(values, val)
                end
            catch
                continue
            end
        end

        if !isempty(values)
            push!(matrix, values)
        end
    end

    if isempty(matrix)
        error("No valid data found in DDA output")
    end

    matrix_array = reduce(hcat, matrix)'

    @info "Loaded DDA output shape: $(size(matrix_array, 1)) rows × $(size(matrix_array, 2)) columns"

    if size(matrix_array, 1) > 0 && size(matrix_array, 2) >= 10
        @debug "First row sample (first 10 values): $(matrix_array[1, 1:10])"
    end

    if size(matrix_array, 2) > 2
        after_skip = matrix_array[:, 3:end]

        @debug "After skipping first 2 columns: $(size(after_skip, 1)) rows × $(size(after_skip, 2)) columns"

        if size(after_skip, 1) > 0 && size(after_skip, 2) >= 10
            @debug "After skip, first row (first 10 values): $(after_skip[1, 1:10])"
        end

        col_indices = 1:column_stride:size(after_skip, 2)
        extracted = after_skip[:, col_indices]

        if size(extracted, 1) > 0 && size(extracted, 2) >= 5
            @debug "First extracted row sample (first 5 values): $(extracted[1, 1:min(5, size(extracted, 2))])"
        end

        if isempty(extracted) || size(extracted, 2) == 0
            error("No data after column extraction")
        end

        @info "Extracted matrix shape: $(size(extracted, 1)) rows × $(size(extracted, 2)) columns (time windows × delays)"

        transposed = extracted'

        if isempty(transposed) || size(transposed, 2) == 0
            error("Transpose resulted in empty data")
        end

        @info "Transposed to: $(size(transposed, 1)) channels × $(size(transposed, 2)) timepoints"

        return transposed
    else
        return reshape(vec(matrix_array), 1, :)
    end
end
