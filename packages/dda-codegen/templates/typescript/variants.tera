// AUTO-GENERATED from DDA_SPEC.yaml
// DO NOT EDIT - Changes will be overwritten
//
// Generated at: {{ timestamp }}
// Spec version: {{ metadata.spec_version }}
// Generator: dda-codegen v0.1.0

/**
 * DDA Variant Metadata
 *
 * Defines properties and behavior for each DDA analysis variant.
 */
export interface VariantMetadata {
  /** Variant abbreviation (e.g., "ST", "CT", "CD") */
  abbreviation: string;

  /** Full variant name */
  name: string;

  /** Detailed description */
  description: string;

  /** Output file suffix appended by binary */
  outputSuffix: string;

  /**
   * Column stride for parsing output
   * - ST/CT/DE: 4 columns per channel/pair
   * - CD: 2 columns per directed pair
   * - SY: 1 column per channel
   */
  stride: number;

  /** Whether this variant requires CT window parameters */
  requiresCtParams: boolean;
}

/**
 * Registry of all DDA variants
 *
 * This is the canonical list of all supported DDA analysis variants.
 */
export const VARIANT_REGISTRY: ReadonlyArray<VariantMetadata> = [
{%- for entry in sorted_variants %}
  {
    abbreviation: "{{ entry.abbrev }}",
    name: "{{ entry.variant.name }}",
    description: "{{ entry.variant.description }}",
    outputSuffix: "{{ entry.variant.output_suffix }}",
    stride: {{ entry.variant.stride }},
    requiresCtParams: {% if entry.variant.required_params | length > 0 %}true{% else %}false{% endif %},
  },
{%- endfor %}
] as const;

/**
 * SELECT mask bit positions
 *
 * The SELECT mask is a 6-element array controlling which variants to execute.
 * Format: ST CT CD RESERVED DE SY
 */
export const SelectMaskPositions = {
{%- for entry in sorted_variants %}
{%-   if entry.abbrev == "ST" %}
  {{ entry.abbrev }}: 0,
{%-   elif entry.abbrev == "CT" %}
  {{ entry.abbrev }}: 1,
{%-   elif entry.abbrev == "CD" %}
  {{ entry.abbrev }}: 2,
{%-   elif entry.abbrev == "DE" %}
  {{ entry.abbrev }}: 4, // Position 3 is RESERVED
{%-   elif entry.abbrev == "SY" %}
  {{ entry.abbrev }}: 5,
{%-   endif %}
{%- endfor %}
  RESERVED: 3,
} as const;

/**
 * Get variant metadata by abbreviation
 *
 * @param abbrev - Variant abbreviation (e.g., "ST", "CT")
 * @returns VariantMetadata if found, undefined otherwise
 */
export function getVariantByAbbrev(abbrev: string): VariantMetadata | undefined {
  return VARIANT_REGISTRY.find((v) => v.abbreviation === abbrev);
}

/**
 * Get variant metadata by output suffix
 *
 * @param suffix - Output file suffix (e.g., "_DDA_ST")
 * @returns VariantMetadata if found, undefined otherwise
 */
export function getVariantBySuffix(suffix: string): VariantMetadata | undefined {
  return VARIANT_REGISTRY.find((v) => v.outputSuffix === suffix);
}

/**
 * Generate SELECT mask from enabled variants
 *
 * @param variants - List of variant abbreviations to enable (e.g., ["ST", "CT"])
 * @returns 6-element array with 1s for enabled variants, 0s for disabled
 *
 * @example
 * ```typescript
 * const mask = generateSelectMask(["ST", "SY"]);
 * // Result: [1, 0, 0, 0, 0, 1] - ST and SY enabled
 * ```
 */
export function generateSelectMask(variants: string[]): number[] {
  const mask = [0, 0, 0, 0, 0, 0];

  for (const variant of variants) {
    switch (variant) {
{%- for entry in sorted_variants %}
      case "{{ entry.abbrev }}":
        mask[SelectMaskPositions.{{ entry.abbrev }}] = 1;
        break;
{%- endfor %}
      default:
        console.warn(`Unknown variant: ${variant}`);
    }
  }

  return mask;
}

/**
 * Parse SELECT mask to list of enabled variants
 *
 * @param mask - 6-element SELECT mask array
 * @returns Array of enabled variant abbreviations
 *
 * @example
 * ```typescript
 * const mask = [1, 0, 0, 0, 0, 1];
 * const enabled = parseSelectMask(mask);
 * // Result: ["ST", "SY"]
 * ```
 */
export function parseSelectMask(mask: number[]): string[] {
  if (mask.length < 6) {
    throw new Error(`Invalid SELECT mask: expected 6 bits, got ${mask.length}`);
  }

  const enabled: string[] = [];

{%- for entry in sorted_variants %}
  if (mask[SelectMaskPositions.{{ entry.abbrev }}] === 1) {
    enabled.push("{{ entry.abbrev }}");
  }
{%- endfor %}

  return enabled;
}

/**
 * Variant type (for type safety)
 */
export type VariantAbbreviation = {% for entry in sorted_variants %}"{{ entry.abbrev }}"{% if not loop.last %} | {% endif %}{% endfor %};

/**
 * Type guard to check if a string is a valid variant abbreviation
 */
export function isVariantAbbreviation(value: string): value is VariantAbbreviation {
  return VARIANT_REGISTRY.some((v) => v.abbreviation === value);
}
