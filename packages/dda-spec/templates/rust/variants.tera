//! AUTO-GENERATED from DDA Specification v{{ spec_version }}
//! Generated: {{ generated_at }}
//!
//! DO NOT EDIT MANUALLY - Run `cargo run --package dda-spec` to regenerate.

use serde::{Deserialize, Serialize};

/// Size of the SELECT mask ({{ select_mask_size }} bits)
pub const SELECT_MASK_SIZE: usize = {{ select_mask_size }};

/// DDA binary name
pub const BINARY_NAME: &str = "{{ binary_name }}";

/// Whether shell wrapper is required
pub const REQUIRES_SHELL_WRAPPER: bool = {{ requires_shell_wrapper }};

/// Shell command for wrapper
pub const SHELL_COMMAND: &str = "{{ shell_command }}";

/// Supported platforms
pub const SUPPORTED_PLATFORMS: &[&str] = &[
{%- for platform in supported_platforms %}
    "{{ platform }}",
{%- endfor %}
];

/// Channel format for variant input
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ChannelFormat {
    Individual,
    Pairs,
    DirectedPairs,
}

impl ChannelFormat {
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "individual" => Some(Self::Individual),
            "pairs" => Some(Self::Pairs),
            "directed_pairs" => Some(Self::DirectedPairs),
            _ => None,
        }
    }
}

/// Output column specification for a variant
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct OutputColumns {
    pub coefficients: u8,
    pub has_error: bool,
}

/// Complete variant metadata
/// Note: Only Serialize is derived since static references can't be deserialized
#[derive(Debug, Clone, Serialize)]
pub struct VariantMetadata {
    pub abbreviation: &'static str,
    pub name: &'static str,
    pub position: u8,
    pub output_suffix: &'static str,
    pub stride: u8,
    pub reserved: bool,
    #[serde(skip)]
    pub required_params: &'static [&'static str],
    pub channel_format: ChannelFormat,
    pub output_columns: OutputColumns,
    pub documentation: &'static str,
}

impl VariantMetadata {
    /// Look up variant by abbreviation
    pub fn from_abbrev(abbrev: &str) -> Option<&'static VariantMetadata> {
        VARIANT_REGISTRY.iter().find(|v| v.abbreviation == abbrev)
    }

    /// Look up variant by output suffix
    pub fn from_suffix(suffix: &str) -> Option<&'static VariantMetadata> {
        VARIANT_REGISTRY.iter().find(|v| v.output_suffix == suffix)
    }

    /// Look up variant by position
    pub fn from_position(pos: u8) -> Option<&'static VariantMetadata> {
        VARIANT_REGISTRY.iter().find(|v| v.position == pos)
    }

    /// Get all non-reserved variants
    pub fn active_variants() -> impl Iterator<Item = &'static VariantMetadata> {
        VARIANT_REGISTRY.iter().filter(|v| !v.reserved)
    }
}

// =============================================================================
// VARIANT DEFINITIONS
// =============================================================================

{% for variant in variants %}
/// {{ variant.name }} ({{ variant.abbreviation }}) - Position {{ variant.position }}
///
/// {{ variant.documentation }}
pub const {{ variant.abbreviation }}: VariantMetadata = VariantMetadata {
    abbreviation: "{{ variant.abbreviation }}",
    name: "{{ variant.name }}",
    position: {{ variant.position }},
    output_suffix: "{{ variant.output_suffix }}",
    stride: {{ variant.stride }},
    reserved: {{ variant.reserved }},
    required_params: &[{% for param in variant.required_params %}"{{ param }}"{% if not loop.last %}, {% endif %}{% endfor %}],
    channel_format: ChannelFormat::{{ variant.channel_format | pascal_case }},
    output_columns: OutputColumns {
        coefficients: {{ variant.output_columns.coefficients }},
        has_error: {{ variant.output_columns.has_error }},
    },
    documentation: "{{ variant.documentation }}",
};

{% endfor %}

/// All variants in SELECT mask order
pub const VARIANT_REGISTRY: &[VariantMetadata] = &[
{%- for abbrev in variant_order %}
    {{ abbrev }},
{%- endfor %}
];

/// Variant abbreviations in SELECT mask order
pub const VARIANT_ORDER: &[&str] = &[
{%- for abbrev in variant_order %}
    "{{ abbrev }}",
{%- endfor %}
];

// =============================================================================
// SELECT MASK UTILITIES
// =============================================================================

/// Generate a SELECT mask from variant abbreviations
pub fn generate_select_mask(variants: &[&str]) -> [u8; SELECT_MASK_SIZE] {
    let mut mask = [0u8; SELECT_MASK_SIZE];
    for abbrev in variants {
        if let Some(variant) = VariantMetadata::from_abbrev(abbrev) {
            mask[variant.position as usize] = 1;
        }
    }
    mask
}

/// Parse a SELECT mask back to variant abbreviations
pub fn parse_select_mask(mask: &[u8]) -> Vec<&'static str> {
    mask.iter()
        .enumerate()
        .filter(|(_, &bit)| bit == 1)
        .filter_map(|(pos, _)| VariantMetadata::from_position(pos as u8))
        .filter(|v| !v.reserved)
        .map(|v| v.abbreviation)
        .collect()
}

/// Format SELECT mask as space-separated string for CLI
pub fn format_select_mask(mask: &[u8; SELECT_MASK_SIZE]) -> String {
    mask.iter()
        .map(|b| b.to_string())
        .collect::<Vec<_>>()
        .join(" ")
}

// =============================================================================
// SELECT MASK POSITION CONSTANTS
// =============================================================================

pub mod select_mask_positions {
{%- for variant in variants %}
    /// Position of {{ variant.abbreviation }} in SELECT mask
    pub const {{ variant.abbreviation }}: usize = {{ variant.position }};
{%- endfor %}
}

// =============================================================================
// FILE TYPES
// =============================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FileType {
{%- for ft in file_types %}
    {{ ft.name }},
{%- endfor %}
}

impl FileType {
    pub fn flag(&self) -> &'static str {
        match self {
{%- for ft in file_types %}
            Self::{{ ft.name }} => "{{ ft.flag }}",
{%- endfor %}
        }
    }

    pub fn from_extension(ext: &str) -> Option<Self> {
        match ext.to_lowercase().as_str() {
{%- for ft in file_types %}
{%- for ext in ft.extensions %}
            "{{ ext }}" => Some(Self::{{ ft.name }}),
{%- endfor %}
{%- endfor %}
            _ => None,
        }
    }
}

// =============================================================================
// BINARY RESOLUTION
// =============================================================================

/// Environment variable for explicit binary path
pub const BINARY_ENV_VAR: &str = "{{ binary_resolution.env_var }}";

/// Environment variable for DDA home directory
pub const BINARY_HOME_ENV_VAR: &str = "{{ binary_resolution.home_env_var }}";

/// Default search paths (in priority order)
pub const DEFAULT_BINARY_PATHS: &[&str] = &[
{%- for path in binary_resolution.default_paths %}
    "{{ path }}",
{%- endfor %}
];

/// Find the DDA binary.
///
/// Resolution order:
/// 1. Explicit path (if provided)
/// 2. ${{ binary_resolution.env_var }} environment variable
/// 3. ${{ binary_resolution.home_env_var }}/bin/ directory
/// 4. Default search paths
///
/// # Arguments
/// * `explicit_path` - Optional explicit path to binary
///
/// # Returns
/// Path to binary if found, None otherwise
pub fn find_binary(explicit_path: Option<&str>) -> Option<std::path::PathBuf> {
    use std::path::PathBuf;

    // Helper to expand ~ in paths
    fn expand_path(path: &str) -> PathBuf {
        if path.starts_with("~/") {
            if let Some(home) = std::env::var_os("HOME") {
                return PathBuf::from(home).join(&path[2..]);
            }
        }
        PathBuf::from(path)
    }

    // 1. Explicit path
    if let Some(path) = explicit_path {
        let p = expand_path(path);
        if p.exists() {
            return Some(p);
        }
        return None;
    }

    // 2. Environment variable for full path
    if let Ok(env_path) = std::env::var(BINARY_ENV_VAR) {
        let p = expand_path(&env_path);
        if p.exists() {
            return Some(p);
        }
    }

    // 3. DDA_HOME environment variable
    if let Ok(home_path) = std::env::var(BINARY_HOME_ENV_VAR) {
        let p = expand_path(&home_path).join("bin").join(BINARY_NAME);
        if p.exists() {
            return Some(p);
        }
    }

    // 4. Default search paths
    for search_path in DEFAULT_BINARY_PATHS {
        let p = expand_path(search_path).join(BINARY_NAME);
        if p.exists() {
            return Some(p);
        }
    }

    None
}

/// Find the DDA binary or return an error.
///
/// Same as `find_binary()` but returns an error if not found.
pub fn require_binary(explicit_path: Option<&str>) -> Result<std::path::PathBuf, String> {
    find_binary(explicit_path).ok_or_else(|| {
        format!(
            "DDA binary '{}' not found. Set ${} or ${}, or install to one of: {:?}",
            BINARY_NAME, BINARY_ENV_VAR, BINARY_HOME_ENV_VAR, DEFAULT_BINARY_PATHS
        )
    })
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_variant_registry_size() {
        assert_eq!(VARIANT_REGISTRY.len(), {{ select_mask_size }});
    }

    #[test]
    fn test_variant_lookup_by_abbrev() {
{%- for variant in variants %}
{%- if not variant.reserved %}
        assert!(VariantMetadata::from_abbrev("{{ variant.abbreviation }}").is_some());
{%- endif %}
{%- endfor %}
        assert!(VariantMetadata::from_abbrev("INVALID").is_none());
    }

    #[test]
    fn test_variant_lookup_by_suffix() {
{%- for variant in variants %}
{%- if not variant.reserved %}
        assert!(VariantMetadata::from_suffix("{{ variant.output_suffix }}").is_some());
{%- endif %}
{%- endfor %}
    }

    #[test]
    fn test_select_mask_generation() {
        let mask = generate_select_mask(&["ST", "SY"]);
        assert_eq!(mask[select_mask_positions::ST], 1);
        assert_eq!(mask[select_mask_positions::SY], 1);
        assert_eq!(mask[select_mask_positions::CT], 0);
    }

    #[test]
    fn test_select_mask_parsing() {
        let mask = [1, 1, 0, 0, 1, 0];
        let variants = parse_select_mask(&mask);
        assert!(variants.contains(&"ST"));
        assert!(variants.contains(&"CT"));
        assert!(variants.contains(&"DE"));
        assert!(!variants.contains(&"CD"));
    }

    #[test]
    fn test_file_type_flags() {
{%- for ft in file_types %}
        assert_eq!(FileType::{{ ft.name }}.flag(), "{{ ft.flag }}");
{%- endfor %}
    }

    #[test]
    fn test_file_type_detection() {
{%- for ft in file_types %}
{%- for ext in ft.extensions %}
        assert_eq!(FileType::from_extension("{{ ext }}"), Some(FileType::{{ ft.name }}));
{%- endfor %}
{%- endfor %}
        assert!(FileType::from_extension("unknown").is_none());
    }

    #[test]
    fn test_binary_name() {
        assert_eq!(BINARY_NAME, "{{ binary_name }}");
    }

    #[test]
    fn test_stride_values() {
{%- for variant in variants %}
{%- if not variant.reserved %}
        assert_eq!({{ variant.abbreviation }}.stride, {{ variant.stride }});
{%- endif %}
{%- endfor %}
    }
}
