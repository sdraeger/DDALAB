/**
 * AUTO-GENERATED from DDA Specification v{{ spec_version }}
 * Generated: {{ generated_at }}
 *
 * DO NOT EDIT MANUALLY - Run `cargo run --package dda-spec` to regenerate.
 */

// =============================================================================
// CONSTANTS
// =============================================================================

export const SPEC_VERSION = "{{ spec_version }}" as const;
export const SELECT_MASK_SIZE = {{ select_mask_size }} as const;
export const BINARY_NAME = "{{ binary_name }}" as const;
export const REQUIRES_SHELL_WRAPPER = {{ requires_shell_wrapper }} as const;
export const SHELL_COMMAND = "{{ shell_command }}" as const;
export const SUPPORTED_PLATFORMS = [
{%- for platform in supported_platforms %}
  "{{ platform }}",
{%- endfor %}
] as const;

// =============================================================================
// TYPES
// =============================================================================

export type ChannelFormat = "individual" | "pairs" | "directed_pairs";

export type FileTypeName = {% for ft in file_types %}"{{ ft.name }}"{% if not loop.last %} | {% endif %}{% endfor %};

export interface OutputColumns {
  readonly coefficients: number;
  readonly hasError: boolean;
  readonly description: string;
}

export interface VariantMetadata {
  readonly abbreviation: VariantAbbreviation;
  readonly name: string;
  readonly position: number;
  readonly outputSuffix: string;
  readonly stride: number;
  readonly reserved: boolean;
  readonly requiredParams: readonly string[];
  readonly channelFormat: ChannelFormat;
  readonly outputColumns: OutputColumns;
  readonly documentation: string;
}

export type VariantAbbreviation = {% for abbrev in variant_order %}"{{ abbrev }}"{% if not loop.last %} | {% endif %}{% endfor %};

export interface FileTypeInfo {
  readonly name: FileTypeName;
  readonly flag: string;
  readonly extensions: readonly string[];
}

// =============================================================================
// VARIANT DEFINITIONS
// =============================================================================

{% for variant in variants %}
/**
 * {{ variant.name }} ({{ variant.abbreviation }}) - Position {{ variant.position }}
 *
 * {{ variant.documentation }}
 */
export const {{ variant.abbreviation }}: VariantMetadata = {
  abbreviation: "{{ variant.abbreviation }}",
  name: "{{ variant.name }}",
  position: {{ variant.position }},
  outputSuffix: "{{ variant.output_suffix }}",
  stride: {{ variant.stride }},
  reserved: {{ variant.reserved }},
  requiredParams: [{% for param in variant.required_params %}"{{ param }}"{% if not loop.last %}, {% endif %}{% endfor %}],
  channelFormat: "{{ variant.channel_format }}",
  outputColumns: {
    coefficients: {{ variant.output_columns.coefficients }},
    hasError: {{ variant.output_columns.has_error }},
    description: "{{ variant.output_columns.description }}",
  },
  documentation: "{{ variant.documentation }}",
} as const;

{% endfor %}

/** All variants in SELECT mask order */
export const VARIANT_REGISTRY: readonly VariantMetadata[] = [
{%- for abbrev in variant_order %}
  {{ abbrev }},
{%- endfor %}
] as const;

/** Variant abbreviations in SELECT mask order */
export const VARIANT_ORDER: readonly VariantAbbreviation[] = [
{%- for abbrev in variant_order %}
  "{{ abbrev }}",
{%- endfor %}
] as const;

// =============================================================================
// SELECT MASK POSITIONS
// =============================================================================

export const SELECT_MASK_POSITIONS = {
{%- for variant in variants %}
  {{ variant.abbreviation }}: {{ variant.position }},
{%- endfor %}
} as const;

// =============================================================================
// FILE TYPES
// =============================================================================

export const FILE_TYPES: Record<FileTypeName, FileTypeInfo> = {
{%- for ft in file_types %}
  {{ ft.name }}: {
    name: "{{ ft.name }}",
    flag: "{{ ft.flag }}",
    extensions: [{% for ext in ft.extensions %}"{{ ext }}"{% if not loop.last %}, {% endif %}{% endfor %}],
  },
{%- endfor %}
} as const;

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Look up variant by abbreviation
 */
export function getVariantByAbbrev(abbrev: string): VariantMetadata | undefined {
  return VARIANT_REGISTRY.find((v) => v.abbreviation === abbrev);
}

/**
 * Look up variant by output suffix
 */
export function getVariantBySuffix(suffix: string): VariantMetadata | undefined {
  return VARIANT_REGISTRY.find((v) => v.outputSuffix === suffix);
}

/**
 * Look up variant by position in SELECT mask
 */
export function getVariantByPosition(position: number): VariantMetadata | undefined {
  return VARIANT_REGISTRY.find((v) => v.position === position);
}

/**
 * Get all non-reserved variants
 */
export function getActiveVariants(): VariantMetadata[] {
  return VARIANT_REGISTRY.filter((v) => !v.reserved);
}

/**
 * Type guard to check if a string is a valid variant abbreviation
 */
export function isVariantAbbreviation(value: string): value is VariantAbbreviation {
  return VARIANT_ORDER.includes(value as VariantAbbreviation);
}

/**
 * Generate a SELECT mask from variant abbreviations
 *
 * @example
 * generateSelectMask(["ST", "SY"]) // [1, 0, 0, 0, 0, 1]
 */
export function generateSelectMask(variants: string[]): number[] {
  const mask = new Array(SELECT_MASK_SIZE).fill(0);
  for (const abbrev of variants) {
    const variant = getVariantByAbbrev(abbrev);
    if (variant) {
      mask[variant.position] = 1;
    }
  }
  return mask;
}

/**
 * Parse a SELECT mask back to variant abbreviations
 *
 * @example
 * parseSelectMask([1, 0, 0, 0, 0, 1]) // ["ST", "SY"]
 */
export function parseSelectMask(mask: number[]): VariantAbbreviation[] {
  const result: VariantAbbreviation[] = [];
  for (let pos = 0; pos < mask.length; pos++) {
    if (mask[pos] === 1) {
      const variant = getVariantByPosition(pos);
      if (variant && !variant.reserved) {
        result.push(variant.abbreviation);
      }
    }
  }
  return result;
}

/**
 * Format SELECT mask as space-separated string for CLI
 *
 * @example
 * formatSelectMask([1, 1, 0, 0, 0, 1]) // "1 1 0 0 0 1"
 */
export function formatSelectMask(mask: number[]): string {
  return mask.join(" ");
}

/**
 * Check if variant requires CT window parameters
 */
export function requiresCtParams(variant: VariantMetadata): boolean {
  return variant.requiredParams.includes("-WL_CT");
}

/**
 * Detect file type from extension
 */
export function getFileTypeFromExtension(ext: string): FileTypeInfo | undefined {
  const normalizedExt = ext.toLowerCase().replace(/^\./, "");
  for (const fileType of Object.values(FILE_TYPES)) {
    if (fileType.extensions.includes(normalizedExt)) {
      return fileType;
    }
  }
  return undefined;
}

// =============================================================================
// SCALE PARAMETERS
// =============================================================================

export interface ScaleParameters {
  scaleMin: number;
  scaleMax: number;
  scaleNum: number;
}

export const DEFAULT_SCALE_PARAMETERS: ScaleParameters = {
  scaleMin: {{ scale_defaults.scale_min }},
  scaleMax: {{ scale_defaults.scale_max }},
  scaleNum: {{ scale_defaults.scale_num }},
};

/**
 * Generate delay values from scale parameters
 */
export function generateDelays(params: ScaleParameters): number[] {
  if (params.scaleNum === 1) {
    return [Math.round(params.scaleMin)];
  }

  const step = (params.scaleMax - params.scaleMin) / (params.scaleNum - 1);
  return Array.from({ length: params.scaleNum }, (_, i) =>
    Math.round(params.scaleMin + i * step)
  );
}
