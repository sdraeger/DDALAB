"""
AUTO-GENERATED from DDA Specification v{{ spec_version }}
Generated: {{ generated_at }}

DO NOT EDIT MANUALLY - Run `cargo run --package dda-spec` to regenerate.
"""

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional

# =============================================================================
# CONSTANTS
# =============================================================================

SPEC_VERSION = "{{ spec_version }}"
SELECT_MASK_SIZE = {{ select_mask_size }}
BINARY_NAME = "{{ binary_name }}"
REQUIRES_SHELL_WRAPPER = {{ requires_shell_wrapper | pybool }}
SHELL_COMMAND = "{{ shell_command }}"
SUPPORTED_PLATFORMS = [
{%- for platform in supported_platforms %}
    "{{ platform }}",
{%- endfor %}
]


# =============================================================================
# ENUMS
# =============================================================================

class ChannelFormat(Enum):
    """Channel format for variant input."""
    INDIVIDUAL = "individual"
    PAIRS = "pairs"
    DIRECTED_PAIRS = "directed_pairs"


class FileType(Enum):
    """Supported input file types."""
{%- for ft in file_types %}
    {{ ft.name }} = "{{ ft.name }}"
{%- endfor %}

    @property
    def flag(self) -> str:
        """Get the CLI flag for this file type."""
        flags = {
{%- for ft in file_types %}
            FileType.{{ ft.name }}: "{{ ft.flag }}",
{%- endfor %}
        }
        return flags[self]

    @classmethod
    def from_extension(cls, ext: str) -> Optional["FileType"]:
        """Detect file type from extension."""
        ext = ext.lower().lstrip(".")
        mapping = {
{%- for ft in file_types %}
{%- for ext in ft.extensions %}
            "{{ ext }}": cls.{{ ft.name }},
{%- endfor %}
{%- endfor %}
        }
        return mapping.get(ext)


# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass(frozen=True)
class OutputColumns:
    """Output column specification for a variant."""
    coefficients: int
    has_error: bool
    description: str


@dataclass(frozen=True)
class VariantMetadata:
    """Complete variant metadata."""
    abbreviation: str
    name: str
    position: int
    output_suffix: str
    stride: int
    reserved: bool
    required_params: tuple
    channel_format: ChannelFormat
    output_columns: OutputColumns
    documentation: str

    def requires_ct_params(self) -> bool:
        """Check if this variant requires CT window parameters."""
        return "-WL_CT" in self.required_params


# =============================================================================
# VARIANT DEFINITIONS
# =============================================================================

{% for variant in variants %}
{{ variant.abbreviation }} = VariantMetadata(
    abbreviation="{{ variant.abbreviation }}",
    name="{{ variant.name }}",
    position={{ variant.position }},
    output_suffix="{{ variant.output_suffix }}",
    stride={{ variant.stride }},
    reserved={{ variant.reserved | pybool }},
    required_params=({% for param in variant.required_params %}"{{ param }}", {% endfor %}),
    channel_format=ChannelFormat.{{ variant.channel_format | upper }},
    output_columns=OutputColumns(
        coefficients={{ variant.output_columns.coefficients }},
        has_error={{ variant.output_columns.has_error | pybool }},
        description="{{ variant.output_columns.description }}",
    ),
    documentation="{{ variant.documentation }}",
)

{% endfor %}

# All variants in SELECT mask order
VARIANT_REGISTRY: tuple = (
{%- for abbrev in variant_order %}
    {{ abbrev }},
{%- endfor %}
)

# Variant abbreviations in SELECT mask order
VARIANT_ORDER: tuple = (
{%- for abbrev in variant_order %}
    "{{ abbrev }}",
{%- endfor %}
)


# =============================================================================
# SELECT MASK POSITIONS
# =============================================================================

class SelectMaskPositions:
    """Position constants for SELECT mask."""
{%- for variant in variants %}
    {{ variant.abbreviation }}: int = {{ variant.position }}
{%- endfor %}


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def get_variant_by_abbrev(abbrev: str) -> Optional[VariantMetadata]:
    """Look up variant by abbreviation."""
    for variant in VARIANT_REGISTRY:
        if variant.abbreviation == abbrev:
            return variant
    return None


def get_variant_by_suffix(suffix: str) -> Optional[VariantMetadata]:
    """Look up variant by output suffix."""
    for variant in VARIANT_REGISTRY:
        if variant.output_suffix == suffix:
            return variant
    return None


def get_variant_by_position(position: int) -> Optional[VariantMetadata]:
    """Look up variant by position in SELECT mask."""
    for variant in VARIANT_REGISTRY:
        if variant.position == position:
            return variant
    return None


def active_variants() -> List[VariantMetadata]:
    """Get all non-reserved variants."""
    return [v for v in VARIANT_REGISTRY if not v.reserved]


def generate_select_mask(variants: List[str]) -> List[int]:
    """Generate a SELECT mask from variant abbreviations.

    Args:
        variants: List of variant abbreviations (e.g., ["ST", "SY"])

    Returns:
        6-element list of 0s and 1s

    Example:
        >>> generate_select_mask(["ST", "SY"])
        [1, 0, 0, 0, 0, 1]
    """
    mask = [0] * SELECT_MASK_SIZE
    for abbrev in variants:
        variant = get_variant_by_abbrev(abbrev)
        if variant:
            mask[variant.position] = 1
    return mask


def parse_select_mask(mask: List[int]) -> List[str]:
    """Parse a SELECT mask back to variant abbreviations.

    Args:
        mask: 6-element list of 0s and 1s

    Returns:
        List of variant abbreviations (excludes RESERVED)

    Example:
        >>> parse_select_mask([1, 0, 0, 0, 0, 1])
        ['ST', 'SY']
    """
    result = []
    for pos, bit in enumerate(mask):
        if bit == 1:
            variant = get_variant_by_position(pos)
            if variant and not variant.reserved:
                result.append(variant.abbreviation)
    return result


def format_select_mask(mask: List[int]) -> str:
    """Format SELECT mask as space-separated string for CLI.

    Example:
        >>> format_select_mask([1, 1, 0, 0, 0, 1])
        '1 1 0 0 0 1'
    """
    return " ".join(str(b) for b in mask)


# =============================================================================
# BINARY RESOLUTION
# =============================================================================

# Environment variable for explicit binary path
BINARY_ENV_VAR = "{{ binary_resolution.env_var }}"

# Environment variable for DDA home directory
BINARY_HOME_ENV_VAR = "{{ binary_resolution.home_env_var }}"

# Default search paths (in priority order)
DEFAULT_BINARY_PATHS = [
{%- for path in binary_resolution.default_paths %}
    "{{ path }}",
{%- endfor %}
]


def find_binary(explicit_path: Optional[str] = None) -> Optional[str]:
    """Find the DDA binary.

    Resolution order:
    1. Explicit path (if provided)
    2. ${{ binary_resolution.env_var }} environment variable
    3. ${{ binary_resolution.home_env_var }}/bin/ directory
    4. Default search paths

    Args:
        explicit_path: Optional explicit path to binary

    Returns:
        Path to binary if found, None otherwise

    Example:
        >>> path = find_binary()  # Auto-discover
        >>> path = find_binary("/opt/dda/bin/run_DDA_AsciiEdf")  # Explicit
    """
    import os
    from pathlib import Path

    # 1. Explicit path
    if explicit_path:
        p = Path(explicit_path).expanduser()
        if p.exists():
            return str(p)
        return None

    # 2. Environment variable for full path
    env_path = os.environ.get(BINARY_ENV_VAR)
    if env_path:
        p = Path(env_path).expanduser()
        if p.exists():
            return str(p)

    # 3. DDA_HOME environment variable
    home_path = os.environ.get(BINARY_HOME_ENV_VAR)
    if home_path:
        p = Path(home_path).expanduser() / "bin" / BINARY_NAME
        if p.exists():
            return str(p)

    # 4. Default search paths
    for search_path in DEFAULT_BINARY_PATHS:
        p = Path(search_path).expanduser() / BINARY_NAME
        if p.exists():
            return str(p)

    return None


def require_binary(explicit_path: Optional[str] = None) -> str:
    """Find the DDA binary or raise an error.

    Same as find_binary() but raises FileNotFoundError if not found.

    Args:
        explicit_path: Optional explicit path to binary

    Returns:
        Path to binary

    Raises:
        FileNotFoundError: If binary cannot be found
    """
    path = find_binary(explicit_path)
    if path is None:
        raise FileNotFoundError(
            f"DDA binary '{BINARY_NAME}' not found. "
            f"Set ${BINARY_ENV_VAR} or ${BINARY_HOME_ENV_VAR}, "
            f"or install to one of: {DEFAULT_BINARY_PATHS}"
        )
    return path


# =============================================================================
# DELAYS
# =============================================================================

# Default delay values (integers)
DEFAULT_DELAYS: tuple = (
{%- for delay in default_delays %}
    {{ delay }},
{%- endfor %}
)


# =============================================================================
# EXPORT
# =============================================================================

__all__ = [
    # Constants
    "SPEC_VERSION",
    "SELECT_MASK_SIZE",
    "BINARY_NAME",
    "REQUIRES_SHELL_WRAPPER",
    "SHELL_COMMAND",
    "SUPPORTED_PLATFORMS",
    # Binary resolution
    "BINARY_ENV_VAR",
    "BINARY_HOME_ENV_VAR",
    "DEFAULT_BINARY_PATHS",
    "find_binary",
    "require_binary",
    # Enums
    "ChannelFormat",
    "FileType",
    # Data classes
    "OutputColumns",
    "VariantMetadata",
    # Variants
{%- for variant in variants %}
    "{{ variant.abbreviation }}",
{%- endfor %}
    "VARIANT_REGISTRY",
    "VARIANT_ORDER",
    # Utilities
    "SelectMaskPositions",
    "get_variant_by_abbrev",
    "get_variant_by_suffix",
    "get_variant_by_position",
    "active_variants",
    "generate_select_mask",
    "parse_select_mask",
    "format_select_mask",
    # Delays
    "DEFAULT_DELAYS",
]
