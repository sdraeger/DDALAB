"""
AUTO-GENERATED from DDA Specification v{{ spec_version }}
Generated: {{ generated_at }}

DO NOT EDIT MANUALLY - Run `cargo run --package dda-spec` to regenerate.
"""

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional

# =============================================================================
# CONSTANTS
# =============================================================================

SPEC_VERSION = "{{ spec_version }}"
SELECT_MASK_SIZE = {{ select_mask_size }}
BINARY_NAME = "{{ binary_name }}"
REQUIRES_SHELL_WRAPPER = {{ requires_shell_wrapper | pybool }}
SHELL_COMMAND = "{{ shell_command }}"
SUPPORTED_PLATFORMS = [
{%- for platform in supported_platforms %}
    "{{ platform }}",
{%- endfor %}
]


# =============================================================================
# ENUMS
# =============================================================================

class ChannelFormat(Enum):
    """Channel format for variant input."""
    INDIVIDUAL = "individual"
    PAIRS = "pairs"
    DIRECTED_PAIRS = "directed_pairs"


class FileType(Enum):
    """Supported input file types."""
{%- for ft in file_types %}
    {{ ft.name }} = "{{ ft.name }}"
{%- endfor %}

    @property
    def flag(self) -> str:
        """Get the CLI flag for this file type."""
        flags = {
{%- for ft in file_types %}
            FileType.{{ ft.name }}: "{{ ft.flag }}",
{%- endfor %}
        }
        return flags[self]

    @classmethod
    def from_extension(cls, ext: str) -> Optional["FileType"]:
        """Detect file type from extension."""
        ext = ext.lower().lstrip(".")
        mapping = {
{%- for ft in file_types %}
{%- for ext in ft.extensions %}
            "{{ ext }}": cls.{{ ft.name }},
{%- endfor %}
{%- endfor %}
        }
        return mapping.get(ext)


# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass(frozen=True)
class OutputColumns:
    """Output column specification for a variant."""
    coefficients: int
    has_error: bool
    description: str


@dataclass(frozen=True)
class VariantMetadata:
    """Complete variant metadata."""
    abbreviation: str
    name: str
    position: int
    output_suffix: str
    stride: int
    reserved: bool
    required_params: tuple
    channel_format: ChannelFormat
    output_columns: OutputColumns
    documentation: str

    def requires_ct_params(self) -> bool:
        """Check if this variant requires CT window parameters."""
        return "-WL_CT" in self.required_params


# =============================================================================
# VARIANT DEFINITIONS
# =============================================================================

{% for variant in variants %}
{{ variant.abbreviation }} = VariantMetadata(
    abbreviation="{{ variant.abbreviation }}",
    name="{{ variant.name }}",
    position={{ variant.position }},
    output_suffix="{{ variant.output_suffix }}",
    stride={{ variant.stride }},
    reserved={{ variant.reserved | pybool }},
    required_params=({% for param in variant.required_params %}"{{ param }}", {% endfor %}),
    channel_format=ChannelFormat.{{ variant.channel_format | upper }},
    output_columns=OutputColumns(
        coefficients={{ variant.output_columns.coefficients }},
        has_error={{ variant.output_columns.has_error | pybool }},
        description="{{ variant.output_columns.description }}",
    ),
    documentation="{{ variant.documentation }}",
)

{% endfor %}

# All variants in SELECT mask order
VARIANT_REGISTRY: tuple = (
{%- for abbrev in variant_order %}
    {{ abbrev }},
{%- endfor %}
)

# Variant abbreviations in SELECT mask order
VARIANT_ORDER: tuple = (
{%- for abbrev in variant_order %}
    "{{ abbrev }}",
{%- endfor %}
)


# =============================================================================
# SELECT MASK POSITIONS
# =============================================================================

class SelectMaskPositions:
    """Position constants for SELECT mask."""
{%- for variant in variants %}
    {{ variant.abbreviation }}: int = {{ variant.position }}
{%- endfor %}


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def get_variant_by_abbrev(abbrev: str) -> Optional[VariantMetadata]:
    """Look up variant by abbreviation."""
    for variant in VARIANT_REGISTRY:
        if variant.abbreviation == abbrev:
            return variant
    return None


def get_variant_by_suffix(suffix: str) -> Optional[VariantMetadata]:
    """Look up variant by output suffix."""
    for variant in VARIANT_REGISTRY:
        if variant.output_suffix == suffix:
            return variant
    return None


def get_variant_by_position(position: int) -> Optional[VariantMetadata]:
    """Look up variant by position in SELECT mask."""
    for variant in VARIANT_REGISTRY:
        if variant.position == position:
            return variant
    return None


def active_variants() -> List[VariantMetadata]:
    """Get all non-reserved variants."""
    return [v for v in VARIANT_REGISTRY if not v.reserved]


def generate_select_mask(variants: List[str]) -> List[int]:
    """Generate a SELECT mask from variant abbreviations.

    Args:
        variants: List of variant abbreviations (e.g., ["ST", "SY"])

    Returns:
        6-element list of 0s and 1s

    Example:
        >>> generate_select_mask(["ST", "SY"])
        [1, 0, 0, 0, 0, 1]
    """
    mask = [0] * SELECT_MASK_SIZE
    for abbrev in variants:
        variant = get_variant_by_abbrev(abbrev)
        if variant:
            mask[variant.position] = 1
    return mask


def parse_select_mask(mask: List[int]) -> List[str]:
    """Parse a SELECT mask back to variant abbreviations.

    Args:
        mask: 6-element list of 0s and 1s

    Returns:
        List of variant abbreviations (excludes RESERVED)

    Example:
        >>> parse_select_mask([1, 0, 0, 0, 0, 1])
        ['ST', 'SY']
    """
    result = []
    for pos, bit in enumerate(mask):
        if bit == 1:
            variant = get_variant_by_position(pos)
            if variant and not variant.reserved:
                result.append(variant.abbreviation)
    return result


def format_select_mask(mask: List[int]) -> str:
    """Format SELECT mask as space-separated string for CLI.

    Example:
        >>> format_select_mask([1, 1, 0, 0, 0, 1])
        '1 1 0 0 0 1'
    """
    return " ".join(str(b) for b in mask)


# =============================================================================
# SCALE PARAMETERS
# =============================================================================

@dataclass
class ScaleParameters:
    """Parameters for generating delay values from scale range."""
    scale_min: float = {{ scale_defaults.scale_min }}
    scale_max: float = {{ scale_defaults.scale_max }}
    scale_num: int = {{ scale_defaults.scale_num }}

    def generate_delays(self) -> List[int]:
        """Generate delay values from scale parameters.

        Returns:
            List of integer delay values
        """
        if self.scale_num == 1:
            return [round(self.scale_min)]

        step = (self.scale_max - self.scale_min) / (self.scale_num - 1)
        return [round(self.scale_min + i * step) for i in range(self.scale_num)]


# =============================================================================
# EXPORT
# =============================================================================

__all__ = [
    # Constants
    "SPEC_VERSION",
    "SELECT_MASK_SIZE",
    "BINARY_NAME",
    "REQUIRES_SHELL_WRAPPER",
    "SHELL_COMMAND",
    "SUPPORTED_PLATFORMS",
    # Enums
    "ChannelFormat",
    "FileType",
    # Data classes
    "OutputColumns",
    "VariantMetadata",
    # Variants
{%- for variant in variants %}
    "{{ variant.abbreviation }}",
{%- endfor %}
    "VARIANT_REGISTRY",
    "VARIANT_ORDER",
    # Utilities
    "SelectMaskPositions",
    "get_variant_by_abbrev",
    "get_variant_by_suffix",
    "get_variant_by_position",
    "active_variants",
    "generate_select_mask",
    "parse_select_mask",
    "format_select_mask",
    "ScaleParameters",
]
