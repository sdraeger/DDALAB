import path from "path";
import fs from "fs/promises";
import { logger } from "../utils/logger";

export interface EnvFileConfig {
  consolidated: { [key: string]: string };
}

export class EnvGeneratorService {
  /**
   * Generates consolidated .env file for Docker Compose deployment
   * Uses the new unified environment system with single .env file
   */
  static async generateContainerEnvFiles(
    setupPath: string,
    baseEnvPath: string
  ): Promise<void> {
    try {
      // Read the base environment file
      const baseEnvContent = await fs.readFile(baseEnvPath, "utf-8");
      const envVars = this.parseEnvFile(baseEnvContent);

      // Process environment variables for production deployment
      const processedVars = this.processEnvVarsForDeployment(envVars);

      // Generate single consolidated .env file for Docker Compose
      await this.writeEnvFile(path.join(setupPath, ".env"), processedVars);

      logger.info("Generated consolidated environment file for Docker Compose");
    } catch (error: any) {
      logger.error(`Failed to generate container env file: ${error.message}`);
      throw error;
    }
  }

  /**
   * Parse environment file content into key-value pairs
   */
  private static parseEnvFile(content: string): { [key: string]: string } {
    const envVars: { [key: string]: string } = {};
    const lines = content.split("\n");

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith("#")) {
        continue;
      }

      const equalIndex = trimmed.indexOf("=");
      if (equalIndex > 0) {
        const key = trimmed.substring(0, equalIndex).trim();
        const value = trimmed.substring(equalIndex + 1).trim();

        // Remove quotes if present
        const cleanValue = value.replace(/^["']|["']$/g, "");
        envVars[key] = cleanValue;
      }
    }

    return envVars;
  }

  /**
   * Process environment variables for production deployment
   * Ensures proper values for Docker Compose environment
   */
  private static processEnvVarsForDeployment(envVars: {
    [key: string]: string;
  }): { [key: string]: string } {
    const processedVars = { ...envVars };

    // Ensure production environment settings
    processedVars["DDALAB_ENVIRONMENT"] = "production";
    processedVars["DDALAB_DEBUG"] = "false";
    processedVars["DDALAB_RELOAD"] = "false";

    // Ensure Docker service hostnames are used
    processedVars["DDALAB_DB_HOST"] = "postgres";
    processedVars["DDALAB_MINIO_HOST"] = "minio:9000";
    processedVars["DDALAB_REDIS_HOST"] = "redis";

    // Ensure consistent MinIO credentials between DDALAB_ and MINIO_ prefixes
    if (processedVars["DDALAB_MINIO_ACCESS_KEY"]) {
      processedVars["MINIO_ROOT_USER"] =
        processedVars["DDALAB_MINIO_ACCESS_KEY"];
    }
    if (processedVars["DDALAB_MINIO_SECRET_KEY"]) {
      processedVars["MINIO_ROOT_PASSWORD"] =
        processedVars["DDALAB_MINIO_SECRET_KEY"];
    }

    // Set production paths
    processedVars["DDALAB_DATA_DIR"] = "/app/data";

    // Ensure observability services use Docker hostnames
    processedVars["DDALAB_OTLP_HOST"] = "jaeger";

    // Set production Next.js URLs to point to Traefik proxy
    processedVars["NEXT_PUBLIC_API_URL"] = "https://localhost";
    processedVars["NEXT_PUBLIC_APP_URL"] = "https://localhost";

    logger.info("Processed environment variables for production deployment");
    return processedVars;
  }

  /**
   * Check if an environment variable should be included in deployment
   */
  private static shouldIncludeVar(key: string): boolean {
    // Exclude development-only variables
    const developmentOnly = [
      "DDALAB_DDA_BINARY_PATH", // Will be set in container
    ];

    return !developmentOnly.includes(key);
  }

  /**
   * Write environment variables to a file
   */
  private static async writeEnvFile(
    filePath: string,
    envVars: { [key: string]: string }
  ): Promise<void> {
    const lines: string[] = [
      "# Auto-generated environment file for container",
      "# Do not edit manually - regenerated by configmanager",
      "",
    ];

    for (const [key, value] of Object.entries(envVars)) {
      // Escape values that contain special characters
      const escapedValue =
        value.includes(" ") || value.includes("$") || value.includes('"')
          ? `"${value.replace(/"/g, '\\"')}"`
          : value;

      lines.push(`${key}=${escapedValue}`);
    }

    await fs.writeFile(filePath, lines.join("\n"), "utf-8");
    logger.info(`Generated env file: ${filePath}`);
  }

  /**
   * Clean up generated environment files
   */
  static async cleanupGeneratedEnvFiles(setupPath: string): Promise<void> {
    try {
      const envPath = path.join(setupPath, ".env");

      await fs.unlink(envPath).catch(() => {
        // Ignore if file doesn't exist
      });

      logger.info("Cleaned up generated environment file");
    } catch (error: any) {
      logger.warn(`Failed to cleanup env file: ${error.message}`);
    }
  }
}
