import type { DDAResult } from "@/types/api";

interface MatlabExportOptions {
  variant?: string;
  channels?: string[];
}

/**
 * Generate a MATLAB script that reproduces a DDA analysis.
 *
 * The script:
 * 1. Documents all analysis parameters as a struct
 * 2. Embeds the DDA results as MATLAB arrays
 * 3. Provides a plotting section that recreates the DDALAB heatmap
 * 4. Includes a helper to load source data via EEGLAB/FieldTrip
 */
export function generateMatlabScript(
  result: DDAResult,
  options: MatlabExportOptions = {},
): string {
  const { variant, channels } = options;

  const variantsToExport = result.results.variants.filter((v) => {
    if (variant && v.variant_id !== variant) return false;
    return Object.keys(v.dda_matrix).length > 0;
  });

  const windowLength = result.parameters.window_length ?? 100;
  const windowStep = result.parameters.window_step ?? 10;
  const delays = result.parameters.delay_list || [];
  const startTime = result.parameters.start_time ?? 0;
  const endTime = result.parameters.end_time ?? 0;
  const fileName = result.file_path.split("/").pop() || result.file_path;

  const lines: string[] = [];

  lines.push(`%% Reproducible DDA Analysis — generated by DDALAB`);
  lines.push(`% Analysis ID: ${result.id}`);
  lines.push(`% Source file: ${fileName}`);
  lines.push(`% Created:     ${result.created_at}`);
  lines.push(`%`);
  lines.push(`% This script documents the exact parameters used in DDALAB and`);
  lines.push(
    `% embeds the results as MATLAB arrays for verification/further analysis.`,
  );
  lines.push(``);

  // --- Section 1: Parameters ---
  lines.push(`%% ${"=".repeat(68)}`);
  lines.push(`%  Analysis Parameters`);
  lines.push(`%  ${"=".repeat(68)}`);
  lines.push(``);
  lines.push(`params = struct();`);
  lines.push(`params.file_path = ${matlabString(result.file_path)};`);
  lines.push(`params.channels = ${matlabCellArray(result.channels)};`);
  lines.push(`params.start_time = ${startTime};`);
  lines.push(`params.end_time = ${endTime};`);
  lines.push(`params.window_length = ${windowLength};`);
  lines.push(`params.window_step = ${windowStep};`);
  lines.push(`params.delays = ${matlabArray(delays)};`);
  lines.push(
    `params.variants = ${matlabCellArray(variantsToExport.map((v) => v.variant_id))};`,
  );
  if (result.parameters.model_dimension != null) {
    lines.push(
      `params.model_dimension = ${result.parameters.model_dimension};`,
    );
  }
  if (result.parameters.polynomial_order != null) {
    lines.push(
      `params.polynomial_order = ${result.parameters.polynomial_order};`,
    );
  }
  if (result.parameters.nr_tau != null) {
    lines.push(`params.nr_tau = ${result.parameters.nr_tau};`);
  }
  lines.push(``);

  // --- Section 2: Embedded results ---
  lines.push(`%% ${"=".repeat(68)}`);
  lines.push(`%  DDA Results (from DDALAB)`);
  lines.push(`%  ${"=".repeat(68)}`);
  lines.push(``);
  lines.push(`results = struct();`);

  for (let vi = 0; vi < variantsToExport.length; vi++) {
    const v = variantsToExport[vi];
    const safeId = matlabFieldName(v.variant_id);
    const chans = channels || Object.keys(v.dda_matrix);

    lines.push(``);
    lines.push(`% Variant: ${v.variant_name} (${v.variant_id})`);
    lines.push(
      `results.${safeId}.variant_name = ${matlabString(v.variant_name)};`,
    );
    lines.push(`results.${safeId}.channels = ${matlabCellArray(chans)};`);

    // DDA matrix as a 2D array (channels x windows)
    const matrixRows: string[] = [];
    for (const ch of chans) {
      const values = v.dda_matrix[ch];
      if (values) {
        const formatted = values.map((n) =>
          Number.isFinite(n) ? n.toPrecision(8) : "NaN",
        );
        matrixRows.push(`  ${formatted.join(", ")}`);
      }
    }
    if (matrixRows.length > 0) {
      lines.push(`results.${safeId}.dda_matrix = [`);
      for (let r = 0; r < matrixRows.length; r++) {
        lines.push(matrixRows[r] + (r < matrixRows.length - 1 ? ";" : ""));
      }
      lines.push(`];`);
    }

    // Exponents
    if (Object.keys(v.exponents).length > 0) {
      const expChans: string[] = [];
      const expVals: string[] = [];
      for (const ch of chans) {
        if (v.exponents[ch] !== undefined) {
          expChans.push(ch);
          expVals.push(String(v.exponents[ch]));
        }
      }
      if (expChans.length > 0) {
        lines.push(
          `results.${safeId}.exponent_channels = ${matlabCellArray(expChans)};`,
        );
        lines.push(`results.${safeId}.exponents = [${expVals.join(", ")}];`);
      }
    }

    // Error values
    const errorValues = v.error_values || result.results.error_values || [];
    if (errorValues.length > 0) {
      const formatted = errorValues.map((n) =>
        Number.isFinite(n) ? n.toPrecision(8) : "NaN",
      );
      lines.push(`results.${safeId}.error_values = [${formatted.join(", ")}];`);
    }
  }

  lines.push(``);

  // --- Section 3: Window indices ---
  if (
    result.results.window_indices &&
    result.results.window_indices.length > 0
  ) {
    lines.push(
      `window_indices = ${matlabArray(result.results.window_indices)};`,
    );
  } else {
    const firstVariant = variantsToExport[0];
    const firstChannel = firstVariant
      ? Object.keys(firstVariant.dda_matrix)[0]
      : undefined;
    const numWindows =
      firstVariant && firstChannel
        ? (firstVariant.dda_matrix[firstChannel]?.length ?? 0)
        : 0;
    lines.push(
      `window_indices = 0:${windowStep}:${(numWindows - 1) * windowStep};`,
    );
  }
  lines.push(``);

  // --- Section 4: Load source data ---
  lines.push(`%% ${"=".repeat(68)}`);
  lines.push(`%  Load Source Data (requires EEGLAB or FieldTrip)`);
  lines.push(`%  ${"=".repeat(68)}`);
  lines.push(``);
  lines.push(`% Uncomment the loader for your toolbox:`);
  lines.push(`%`);
  lines.push(`% --- EEGLAB ---`);
  lines.push(`% EEG = pop_loadset('filename', params.file_path);`);
  lines.push(`% EEG = pop_select(EEG, 'channel', params.channels);`);
  lines.push(`%`);
  lines.push(`% --- FieldTrip ---`);
  lines.push(`% cfg = [];`);
  lines.push(`% cfg.dataset = params.file_path;`);
  lines.push(`% cfg.channel = params.channels;`);
  lines.push(`% data = ft_preprocessing(cfg);`);
  lines.push(``);

  // --- Section 5: Visualization ---
  lines.push(`%% ${"=".repeat(68)}`);
  lines.push(`%  Visualization`);
  lines.push(`%  ${"=".repeat(68)}`);
  lines.push(``);
  lines.push(
    `function plot_dda_heatmap(results, variant_field, window_indices)`,
  );
  lines.push(`    if isempty(fieldnames(results))`);
  lines.push(
    `        fprintf('No results to plot. The results struct is empty.\\n');`,
  );
  lines.push(`        return;`);
  lines.push(`    end`);
  lines.push(`    if nargin < 2 || isempty(variant_field)`);
  lines.push(`        fields = fieldnames(results);`);
  lines.push(`        variant_field = fields{1};`);
  lines.push(`    end`);
  lines.push(`    variant = results.(variant_field);`);
  lines.push(`    data = variant.dda_matrix;`);
  lines.push(`    channels = variant.channels;`);
  lines.push(``);
  lines.push(`    figure;`);
  lines.push(`    imagesc(window_indices, 1:size(data, 1), data);`);
  lines.push(`    colormap('jet');`);
  lines.push(`    colorbar;`);
  lines.push(
    `    set(gca, 'YTick', 1:length(channels), 'YTickLabel', channels);`,
  );
  lines.push(`    xlabel('Window index');`);
  lines.push(
    `    title(sprintf('DDA — %s (%s)', variant.variant_name, variant_field));`,
  );
  lines.push(`end`);
  lines.push(``);

  // --- Section 6: Main ---
  lines.push(`%% ${"=".repeat(68)}`);
  lines.push(`%  Main`);
  lines.push(`%  ${"=".repeat(68)}`);
  lines.push(``);
  lines.push(`fprintf('DDA Analysis: %s\\n', params.file_path);`);
  lines.push(`fprintf('Channels: %s\\n', strjoin(params.channels, ', '));`);
  lines.push(
    `fprintf('Parameters: window_length=%d, window_step=%d\\n', params.window_length, params.window_step);`,
  );
  lines.push(`fprintf('Delays: %s\\n', mat2str(params.delays));`);
  lines.push(``);
  lines.push(`variant_fields = fieldnames(results);`);
  lines.push(`if isempty(variant_fields)`);
  lines.push(
    `    fprintf('\\nWarning: No variant results embedded. The analysis may not have completed,\\n');`,
  );
  lines.push(
    `    fprintf('or matrix data was not yet loaded when the export was created.\\n');`,
  );
  lines.push(`else`);
  lines.push(`    for i = 1:length(variant_fields)`);
  lines.push(`        vf = variant_fields{i};`);
  lines.push(`        vdata = results.(vf);`);
  lines.push(`        [n_channels, n_windows] = size(vdata.dda_matrix);`);
  lines.push(
    `        fprintf('  %s: %d channels x %d windows\\n', vf, n_channels, n_windows);`,
  );
  lines.push(`        if isfield(vdata, 'exponents')`);
  lines.push(`            for j = 1:length(vdata.exponent_channels)`);
  lines.push(
    `                fprintf('    %s: exponent = %.4f\\n', vdata.exponent_channels{j}, vdata.exponents(j));`,
  );
  lines.push(`            end`);
  lines.push(`        end`);
  lines.push(`    end`);
  lines.push(`end`);
  lines.push(``);
  lines.push(`% Uncomment to plot:`);
  lines.push(`% plot_dda_heatmap(results, [], window_indices);`);

  return lines.join("\n");
}

export function getDefaultMatlabFilename(result: DDAResult): string {
  const timestamp = new Date(result.created_at)
    .toISOString()
    .replace(/[:.]/g, "-")
    .slice(0, 19);
  const fileName = result.name || result.id.slice(0, 8);
  return `dda_${fileName}_reproduce_${timestamp}.m`;
}

function matlabString(s: string): string {
  return `'${s.replace(/'/g, "''")}'`;
}

function matlabArray(arr: number[]): string {
  if (arr.length === 0) return "[]";
  return `[${arr.join(", ")}]`;
}

function matlabCellArray(arr: string[]): string {
  if (arr.length === 0) return "{}";
  return `{${arr.map((s) => matlabString(s)).join(", ")}}`;
}

function matlabFieldName(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, "_").replace(/^(\d)/, "v$1");
}
