import type { DDAResult } from "@/types/api";

interface JuliaExportOptions {
  variant?: string;
  channels?: string[];
}

/**
 * Generate a Julia script that reproduces a DDA analysis.
 *
 * The script:
 * 1. Documents all analysis parameters as a named tuple
 * 2. Embeds the DDA results as Julia arrays/dictionaries
 * 3. Provides a plotting section using Plots.jl heatmap
 * 4. Includes a helper to load source data via EDF.jl
 */
export function generateJuliaScript(
  result: DDAResult,
  options: JuliaExportOptions = {},
): string {
  const { variant, channels } = options;

  const variantsToExport = result.results.variants.filter((v) => {
    if (variant && v.variant_id !== variant) return false;
    return Object.keys(v.dda_matrix).length > 0;
  });

  const windowLength = result.parameters.window_length ?? 100;
  const windowStep = result.parameters.window_step ?? 10;
  const delays = result.parameters.delay_list || [];
  const startTime = result.parameters.start_time ?? 0;
  const endTime = result.parameters.end_time ?? 0;
  const fileName = result.file_path.split("/").pop() || result.file_path;

  const lines: string[] = [];

  lines.push(`# Reproducible DDA Analysis — generated by DDALAB`);
  lines.push(`# Analysis ID: ${result.id}`);
  lines.push(`# Source file: ${fileName}`);
  lines.push(`# Created:     ${result.created_at}`);
  lines.push(`#`);
  lines.push(`# This script documents the exact parameters used in DDALAB and`);
  lines.push(
    `# embeds the results as Julia arrays for verification/further analysis.`,
  );
  lines.push(``);

  // --- Section 1: Parameters ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Analysis Parameters`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`params = (`);
  lines.push(`    file_path = ${juliaString(result.file_path)},`);
  lines.push(`    channels = ${juliaStringArray(result.channels)},`);
  lines.push(`    start_time = ${startTime},`);
  lines.push(`    end_time = ${endTime},`);
  lines.push(`    window_length = ${windowLength},`);
  lines.push(`    window_step = ${windowStep},`);
  lines.push(`    delays = ${juliaArray(delays)},`);
  lines.push(
    `    variants = ${juliaStringArray(variantsToExport.map((v) => v.variant_id))},`,
  );
  if (result.parameters.model_dimension != null) {
    lines.push(`    model_dimension = ${result.parameters.model_dimension},`);
  }
  if (result.parameters.polynomial_order != null) {
    lines.push(`    polynomial_order = ${result.parameters.polynomial_order},`);
  }
  if (result.parameters.nr_tau != null) {
    lines.push(`    nr_tau = ${result.parameters.nr_tau},`);
  }
  lines.push(`)`);
  lines.push(``);

  // --- Section 2: Embedded results ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# DDA Results (from DDALAB)`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`results = Dict{String, Any}()`);

  for (const v of variantsToExport) {
    const chans = channels || Object.keys(v.dda_matrix);
    lines.push(``);
    lines.push(`# Variant: ${v.variant_name} (${v.variant_id})`);
    lines.push(`results[${juliaString(v.variant_id)}] = Dict{String, Any}(`);
    lines.push(`    "variant_name" => ${juliaString(v.variant_name)},`);
    lines.push(`    "channels" => ${juliaStringArray(chans)},`);

    // DDA matrix as Dict of channel => Vector
    lines.push(`    "dda_matrix" => Dict{String, Vector{Float64}}(`);
    for (const ch of chans) {
      const values = v.dda_matrix[ch];
      if (values) {
        const formatted = values.map((n) =>
          Number.isFinite(n) ? n.toPrecision(8) : "NaN",
        );
        lines.push(`        ${juliaString(ch)} => [${formatted.join(", ")}],`);
      }
    }
    lines.push(`    ),`);

    if (Object.keys(v.exponents).length > 0) {
      lines.push(`    "exponents" => Dict{String, Float64}(`);
      for (const ch of chans) {
        if (v.exponents[ch] !== undefined) {
          lines.push(`        ${juliaString(ch)} => ${v.exponents[ch]},`);
        }
      }
      lines.push(`    ),`);
    }

    const errorValues = v.error_values || result.results.error_values || [];
    if (errorValues.length > 0) {
      const formatted = errorValues.map((n) =>
        Number.isFinite(n) ? n.toPrecision(8) : "NaN",
      );
      lines.push(`    "error_values" => [${formatted.join(", ")}],`);
    }

    lines.push(`)`);
  }

  lines.push(``);

  // --- Section 3: Window indices ---
  if (
    result.results.window_indices &&
    result.results.window_indices.length > 0
  ) {
    lines.push(`window_indices = ${juliaArray(result.results.window_indices)}`);
  } else {
    const firstVariant = variantsToExport[0];
    const firstChannel = firstVariant
      ? Object.keys(firstVariant.dda_matrix)[0]
      : undefined;
    const numWindows =
      firstVariant && firstChannel
        ? (firstVariant.dda_matrix[firstChannel]?.length ?? 0)
        : 0;
    lines.push(
      `window_indices = collect(0:${windowStep}:${(numWindows - 1) * windowStep})`,
    );
  }
  lines.push(``);

  // --- Section 4: Load source data ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Load Source Data (requires EDF.jl: using Pkg; Pkg.add("EDF"))`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`function load_source_data(file_path=params.file_path)`);
  lines.push(`    # using EDF`);
  lines.push(`    # edf = EDF.read(file_path)`);
  lines.push(`    # return edf`);
  lines.push(
    `    @warn "Uncomment the lines above and install EDF.jl to load source data"`,
  );
  lines.push(`    return nothing`);
  lines.push(`end`);
  lines.push(``);

  // --- Section 5: Visualization ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(
    `# Visualization (requires Plots.jl: using Pkg; Pkg.add("Plots"))`,
  );
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`function plot_dda_heatmap(variant_id=nothing)`);
  lines.push(`    if isempty(results)`);
  lines.push(
    `        println("No results to plot. The results dict is empty.")`,
  );
  lines.push(`        return nothing`);
  lines.push(`    end`);
  lines.push(``);
  lines.push(`    using Plots`);
  lines.push(``);
  lines.push(`    if variant_id === nothing`);
  lines.push(`        variant_id = first(keys(results))`);
  lines.push(`    end`);
  lines.push(``);
  lines.push(`    variant = results[variant_id]`);
  lines.push(`    matrix = variant["dda_matrix"]`);
  lines.push(`    channels = variant["channels"]`);
  lines.push(`    data = hcat([matrix[ch] for ch in channels]...)'`);
  lines.push(``);
  lines.push(`    heatmap(window_indices, channels, data,`);
  lines.push(`        xlabel="Window index",`);
  lines.push(`        ylabel="Channel",`);
  lines.push(`        title="DDA — $(variant["variant_name"]) ($variant_id)",`);
  lines.push(`        color=:RdBu,`);
  lines.push(`        size=(900, max(300, length(channels) * 40))`);
  lines.push(`    )`);
  lines.push(`end`);
  lines.push(``);

  // --- Section 6: Main ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Main`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`println("DDA Analysis: $(params.file_path)")`);
  lines.push(`println("Channels: $(join(params.channels, ", "))")`);
  lines.push(
    `println("Parameters: window_length=$(params.window_length), window_step=$(params.window_step)")`,
  );
  lines.push(`println("Delays: $(params.delays)")`);
  lines.push(``);
  lines.push(`if isempty(results)`);
  lines.push(
    `    println("\\nWarning: No variant results embedded. The analysis may not have completed,")`,
  );
  lines.push(
    `    println("or matrix data was not yet loaded when the export was created.")`,
  );
  lines.push(`else`);
  lines.push(`    for (vid, vdata) in results`);
  lines.push(`        n_channels = length(vdata["dda_matrix"])`);
  lines.push(
    `        n_windows = isempty(vdata["dda_matrix"]) ? 0 : length(first(values(vdata["dda_matrix"])))`,
  );
  lines.push(
    `        println("  $vid: $n_channels channels x $n_windows windows")`,
  );
  lines.push(`        if haskey(vdata, "exponents")`);
  lines.push(`            for (ch, exp) in vdata["exponents"]`);
  lines.push(
    `                println("    $ch: exponent = $(round(exp, digits=4))")`,
  );
  lines.push(`            end`);
  lines.push(`        end`);
  lines.push(`    end`);
  lines.push(`end`);
  lines.push(``);
  lines.push(`# Uncomment to load source data and plot:`);
  lines.push(`# raw = load_source_data()`);
  lines.push(`# plot_dda_heatmap()`);

  return lines.join("\n");
}

export function getDefaultJuliaFilename(result: DDAResult): string {
  const timestamp = new Date(result.created_at)
    .toISOString()
    .replace(/[:.]/g, "-")
    .slice(0, 19);
  const fileName = result.name || result.id.slice(0, 8);
  return `dda_${fileName}_reproduce_${timestamp}.jl`;
}

function juliaString(s: string): string {
  return `"${s.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}

function juliaArray(arr: number[]): string {
  if (arr.length === 0) return "Int[]";
  return `[${arr.join(", ")}]`;
}

function juliaStringArray(arr: string[]): string {
  if (arr.length === 0) return "String[]";
  return `[${arr.map((s) => juliaString(s)).join(", ")}]`;
}
