import type { DDAResult } from "@/types/api";

interface PythonExportOptions {
  variant?: string;
  channels?: string[];
}

/**
 * Generate a Python script that reproduces a DDA analysis.
 *
 * The script:
 * 1. Loads the source data file using MNE-Python
 * 2. Documents all analysis parameters
 * 3. Embeds the DDA results as numpy arrays for comparison
 * 4. Provides a plotting section that recreates the DDALAB heatmap
 */
export function generatePythonScript(
  result: DDAResult,
  options: PythonExportOptions = {},
): string {
  const { variant, channels } = options;

  const variantsToExport = result.results.variants.filter((v) => {
    if (variant && v.variant_id !== variant) return false;
    return Object.keys(v.dda_matrix).length > 0;
  });

  const windowLength = result.parameters.window_length ?? 100;
  const windowStep = result.parameters.window_step ?? 10;
  const delays = result.parameters.delay_list || [];
  const startTime = result.parameters.start_time ?? 0;
  const endTime = result.parameters.end_time ?? 0;
  const fileName = result.file_path.split("/").pop() || result.file_path;

  const lines: string[] = [];

  lines.push(`#!/usr/bin/env python3`);
  lines.push(`"""`);
  lines.push(`Reproducible DDA Analysis — generated by DDALAB`);
  lines.push(`Analysis ID: ${result.id}`);
  lines.push(`Source file: ${fileName}`);
  lines.push(`Created:     ${result.created_at}`);
  lines.push(``);
  lines.push(`This script documents the exact parameters used in DDALAB and`);
  lines.push(
    `embeds the results as numpy arrays for verification/further analysis.`,
  );
  lines.push(`"""`);
  lines.push(``);
  lines.push(`import numpy as np`);
  lines.push(`import json`);
  lines.push(`from pathlib import Path`);
  lines.push(``);

  // --- Section 1: Parameters ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Analysis Parameters`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`PARAMS = {`);
  lines.push(`    "file_path": ${JSON.stringify(result.file_path)},`);
  lines.push(`    "channels": ${JSON.stringify(result.channels)},`);
  lines.push(`    "start_time": ${startTime},`);
  lines.push(`    "end_time": ${endTime},`);
  lines.push(`    "window_length": ${windowLength},`);
  lines.push(`    "window_step": ${windowStep},`);
  lines.push(`    "delays": ${JSON.stringify(delays)},`);
  lines.push(
    `    "variants": ${JSON.stringify(variantsToExport.map((v) => v.variant_id))},`,
  );
  if (result.parameters.model_dimension != null) {
    lines.push(`    "model_dimension": ${result.parameters.model_dimension},`);
  }
  if (result.parameters.polynomial_order != null) {
    lines.push(
      `    "polynomial_order": ${result.parameters.polynomial_order},`,
    );
  }
  if (result.parameters.nr_tau != null) {
    lines.push(`    "nr_tau": ${result.parameters.nr_tau},`);
  }
  if (
    result.parameters.model_params &&
    result.parameters.model_params.length > 0
  ) {
    lines.push(
      `    "model_params": ${JSON.stringify(result.parameters.model_params)},`,
    );
  }
  lines.push(`}`);
  lines.push(``);

  // --- Section 2: Embedded results ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# DDA Results (from DDALAB)`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`results = {}`);

  for (const v of variantsToExport) {
    const chans = channels || Object.keys(v.dda_matrix);
    lines.push(``);
    lines.push(`# Variant: ${v.variant_name} (${v.variant_id})`);
    lines.push(`results[${JSON.stringify(v.variant_id)}] = {`);
    lines.push(`    "variant_name": ${JSON.stringify(v.variant_name)},`);
    lines.push(`    "dda_matrix": {`);

    for (const ch of chans) {
      const values = v.dda_matrix[ch];
      if (values) {
        const formatted = values.map((n) =>
          Number.isFinite(n) ? n.toPrecision(8) : "np.nan",
        );
        lines.push(
          `        ${JSON.stringify(ch)}: np.array([${formatted.join(", ")}]),`,
        );
      }
    }

    lines.push(`    },`);

    if (Object.keys(v.exponents).length > 0) {
      lines.push(`    "exponents": {`);
      for (const ch of chans) {
        if (v.exponents[ch] !== undefined) {
          lines.push(`        ${JSON.stringify(ch)}: ${v.exponents[ch]},`);
        }
      }
      lines.push(`    },`);
    }

    const errorValues = v.error_values || result.results.error_values || [];
    if (errorValues.length > 0) {
      const formatted = errorValues.map((n) =>
        Number.isFinite(n) ? n.toPrecision(8) : "np.nan",
      );
      lines.push(`    "error_values": np.array([${formatted.join(", ")}]),`);
    }

    lines.push(`}`);
  }

  lines.push(``);

  // --- Section 3: Window indices ---
  if (
    result.results.window_indices &&
    result.results.window_indices.length > 0
  ) {
    lines.push(
      `window_indices = np.array(${JSON.stringify(result.results.window_indices)})`,
    );
  } else {
    const firstVariant = variantsToExport[0];
    const firstChannel = firstVariant
      ? Object.keys(firstVariant.dda_matrix)[0]
      : undefined;
    const numWindows =
      firstVariant && firstChannel
        ? (firstVariant.dda_matrix[firstChannel]?.length ?? 0)
        : 0;
    lines.push(
      `window_indices = np.arange(0, ${numWindows} * ${windowStep}, ${windowStep})`,
    );
  }
  lines.push(``);

  // --- Section 4: Load source data ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Load Source Data (requires MNE-Python: pip install mne)`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`def load_source_data(file_path=PARAMS["file_path"]):`);
  lines.push(`    """Load the source EEG/MEG file using MNE-Python."""`);
  lines.push(`    try:`);
  lines.push(`        import mne`);
  lines.push(`    except ImportError:`);
  lines.push(
    `        print("MNE-Python not installed. Install with: pip install mne")`,
  );
  lines.push(`        return None`);
  lines.push(``);
  lines.push(`    p = Path(file_path)`);
  lines.push(`    ext = p.suffix.lower()`);
  lines.push(``);
  lines.push(`    loaders = {`);
  lines.push(`        ".edf": mne.io.read_raw_edf,`);
  lines.push(`        ".bdf": mne.io.read_raw_bdf,`);
  lines.push(`        ".fif": mne.io.read_raw_fif,`);
  lines.push(`        ".vhdr": mne.io.read_raw_brainvision,`);
  lines.push(`        ".set": mne.io.read_raw_eeglab,`);
  lines.push(`        ".cnt": mne.io.read_raw_cnt,`);
  lines.push(`    }`);
  lines.push(``);
  lines.push(`    loader = loaders.get(ext)`);
  lines.push(`    if loader is None:`);
  lines.push(
    `        print(f"Unsupported format: {ext}. Supported: {list(loaders.keys())}")`,
  );
  lines.push(`        return None`);
  lines.push(``);
  lines.push(`    raw = loader(str(p), preload=True)`);
  lines.push(`    raw.pick(PARAMS["channels"])`);
  lines.push(
    `    raw.crop(tmin=PARAMS["start_time"], tmax=PARAMS["end_time"])`,
  );
  lines.push(`    return raw`);
  lines.push(``);

  // --- Section 5: Visualization ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Visualization`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`def plot_dda_heatmap(variant_id=None):`);
  lines.push(`    """Plot DDA results as a heatmap matching DDALAB output."""`);
  lines.push(`    if not results:`);
  lines.push(`        print("No results to plot. The results dict is empty.")`);
  lines.push(`        return`);
  lines.push(``);
  lines.push(`    import matplotlib.pyplot as plt`);
  lines.push(``);
  lines.push(`    if variant_id is None:`);
  lines.push(`        variant_id = list(results.keys())[0]`);
  lines.push(``);
  lines.push(`    variant = results[variant_id]`);
  lines.push(`    matrix = variant["dda_matrix"]`);
  lines.push(`    channels = list(matrix.keys())`);
  lines.push(`    data = np.array([matrix[ch] for ch in channels])`);
  lines.push(``);
  lines.push(
    `    fig, ax = plt.subplots(figsize=(12, max(4, len(channels) * 0.5)))`,
  );
  lines.push(`    im = ax.imshow(`);
  lines.push(
    `        data, aspect="auto", interpolation="nearest", cmap="RdBu_r",`,
  );
  lines.push(
    `        extent=[window_indices[0], window_indices[-1], len(channels) - 0.5, -0.5],`,
  );
  lines.push(`    )`);
  lines.push(`    ax.set_yticks(range(len(channels)))`);
  lines.push(`    ax.set_yticklabels(channels)`);
  lines.push(`    ax.set_xlabel("Window index")`);
  lines.push(
    `    ax.set_title(f"DDA — {variant['variant_name']} ({variant_id})")`,
  );
  lines.push(`    plt.colorbar(im, ax=ax, label="DDA value")`);
  lines.push(`    plt.tight_layout()`);
  lines.push(`    plt.show()`);
  lines.push(``);

  // --- Section 6: Main ---
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(`# Main`);
  lines.push(`# ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`if __name__ == "__main__":`);
  lines.push(`    print(f"DDA Analysis: {PARAMS['file_path']}")`);
  lines.push(`    print(f"Channels: {', '.join(PARAMS['channels'])}")`);
  lines.push(
    `    print(f"Parameters: window_length={PARAMS['window_length']}, window_step={PARAMS['window_step']}")`,
  );
  lines.push(`    print(f"Delays: {PARAMS['delays']}")`);
  lines.push(``);
  lines.push(`    if not results:`);
  lines.push(
    `        print("\\nWarning: No variant results embedded. The analysis may not have completed,")`,
  );
  lines.push(
    `        print("or matrix data was not yet loaded when the export was created.")`,
  );
  lines.push(`    else:`);
  lines.push(`        print(f"Variants: {', '.join(v for v in results)}")`);
  lines.push(`        for vid, vdata in results.items():`);
  lines.push(`            n_channels = len(vdata["dda_matrix"])`);
  lines.push(
    `            n_windows = len(next(iter(vdata["dda_matrix"].values()))) if vdata["dda_matrix"] else 0`,
  );
  lines.push(
    `            print(f"  {vid}: {n_channels} channels x {n_windows} windows")`,
  );
  lines.push(`            if "exponents" in vdata:`);
  lines.push(`                for ch, exp in vdata["exponents"].items():`);
  lines.push(`                    print(f"    {ch}: exponent = {exp:.4f}")`);
  lines.push(``);
  lines.push(`    # Uncomment to load source data and plot:`);
  lines.push(`    # raw = load_source_data()`);
  lines.push(`    # plot_dda_heatmap()`);

  return lines.join("\n");
}

export function getDefaultPythonFilename(result: DDAResult): string {
  const timestamp = new Date(result.created_at)
    .toISOString()
    .replace(/[:.]/g, "-")
    .slice(0, 19);
  const fileName = result.name || result.id.slice(0, 8);
  return `dda_${fileName}_reproduce_${timestamp}.py`;
}
