import type { DDAResult } from "@/types/api";

interface RustExportOptions {
  variant?: string;
  channels?: string[];
}

/**
 * Generate a Rust source file that embeds DDA analysis results.
 *
 * The file:
 * 1. Documents all analysis parameters as const/static data
 * 2. Embeds the DDA results as static arrays
 * 3. Provides a main() that prints a summary
 * 4. Can be compiled standalone: rustc reproduce.rs && ./reproduce
 */
export function generateRustScript(
  result: DDAResult,
  options: RustExportOptions = {},
): string {
  const { variant, channels } = options;

  const variantsToExport = result.results.variants.filter((v) => {
    if (variant && v.variant_id !== variant) return false;
    return Object.keys(v.dda_matrix).length > 0;
  });

  const windowLength = result.parameters.window_length ?? 100;
  const windowStep = result.parameters.window_step ?? 10;
  const delays = result.parameters.delay_list || [];
  const startTime = result.parameters.start_time ?? 0;
  const endTime = result.parameters.end_time ?? 0;
  const fileName = result.file_path.split("/").pop() || result.file_path;

  const lines: string[] = [];

  lines.push(`//! Reproducible DDA Analysis â€” generated by DDALAB`);
  lines.push(`//!`);
  lines.push(`//! Analysis ID: ${result.id}`);
  lines.push(`//! Source file: ${fileName}`);
  lines.push(`//! Created:     ${result.created_at}`);
  lines.push(`//!`);
  lines.push(`//! This file documents the exact parameters used in DDALAB and`);
  lines.push(
    `//! embeds the results as static arrays for verification/further analysis.`,
  );
  lines.push(`//!`);
  lines.push(
    `//! Compile and run: rustc ${getDefaultRustFilename(result)} && ./${getDefaultRustFilename(result).replace(".rs", "")}`,
  );
  lines.push(``);
  lines.push(`use std::collections::HashMap;`);
  lines.push(``);

  // --- Section 1: Parameters ---
  lines.push(`// ${"=".repeat(70)}`);
  lines.push(`// Analysis Parameters`);
  lines.push(`// ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`const FILE_PATH: &str = ${rustString(result.file_path)};`);
  lines.push(
    `const CHANNELS: &[&str] = &[${result.channels.map((c) => rustString(c)).join(", ")}];`,
  );
  lines.push(`const START_TIME: f64 = ${startTime}.0;`);
  lines.push(`const END_TIME: f64 = ${endTime}.0;`);
  lines.push(`const WINDOW_LENGTH: usize = ${windowLength};`);
  lines.push(`const WINDOW_STEP: usize = ${windowStep};`);
  lines.push(`const DELAYS: &[i32] = &[${delays.join(", ")}];`);
  if (result.parameters.model_dimension != null) {
    lines.push(
      `const MODEL_DIMENSION: usize = ${result.parameters.model_dimension};`,
    );
  }
  if (result.parameters.polynomial_order != null) {
    lines.push(
      `const POLYNOMIAL_ORDER: usize = ${result.parameters.polynomial_order};`,
    );
  }
  if (result.parameters.nr_tau != null) {
    lines.push(`const NR_TAU: usize = ${result.parameters.nr_tau};`);
  }
  lines.push(``);

  // --- Section 2: Result structs ---
  lines.push(`// ${"=".repeat(70)}`);
  lines.push(`// DDA Results (from DDALAB)`);
  lines.push(`// ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`struct DDAVariant {`);
  lines.push(`    variant_id: &'static str,`);
  lines.push(`    variant_name: &'static str,`);
  lines.push(`    channels: &'static [&'static str],`);
  lines.push(`    dda_matrix: &'static [&'static [f64]],`);
  lines.push(`    exponents: &'static [(&'static str, f64)],`);
  lines.push(`    error_values: &'static [f64],`);
  lines.push(`}`);
  lines.push(``);

  for (const v of variantsToExport) {
    const chans = channels || Object.keys(v.dda_matrix);
    const safeId = rustIdentifier(v.variant_id);

    lines.push(`// Variant: ${v.variant_name} (${v.variant_id})`);

    // Channel names
    lines.push(
      `const ${safeId}_CHANNELS: &[&str] = &[${chans.map((c) => rustString(c)).join(", ")}];`,
    );

    // Per-channel arrays
    for (const ch of chans) {
      const values = v.dda_matrix[ch];
      if (values) {
        const safeCh = rustIdentifier(ch);
        const formatted = values.map((n) =>
          Number.isFinite(n) ? formatRustFloat(n) : "f64::NAN",
        );
        lines.push(
          `const ${safeId}_${safeCh}: &[f64] = &[${formatted.join(", ")}];`,
        );
      }
    }

    // Matrix array of slices
    const matrixEntries = chans
      .filter((ch) => v.dda_matrix[ch])
      .map((ch) => `${safeId}_${rustIdentifier(ch)}`);
    lines.push(
      `const ${safeId}_MATRIX: &[&[f64]] = &[${matrixEntries.join(", ")}];`,
    );

    // Exponents
    const expEntries: string[] = [];
    for (const ch of chans) {
      if (v.exponents[ch] !== undefined) {
        expEntries.push(
          `(${rustString(ch)}, ${formatRustFloat(v.exponents[ch])})`,
        );
      }
    }
    lines.push(
      `const ${safeId}_EXPONENTS: &[(&str, f64)] = &[${expEntries.join(", ")}];`,
    );

    // Error values
    const errorValues = v.error_values || result.results.error_values || [];
    if (errorValues.length > 0) {
      const formatted = errorValues.map((n) =>
        Number.isFinite(n) ? formatRustFloat(n) : "f64::NAN",
      );
      lines.push(
        `const ${safeId}_ERRORS: &[f64] = &[${formatted.join(", ")}];`,
      );
    } else {
      lines.push(`const ${safeId}_ERRORS: &[f64] = &[];`);
    }

    // Variant struct instance
    lines.push(``);
    lines.push(`const ${safeId}: DDAVariant = DDAVariant {`);
    lines.push(`    variant_id: ${rustString(v.variant_id)},`);
    lines.push(`    variant_name: ${rustString(v.variant_name)},`);
    lines.push(`    channels: ${safeId}_CHANNELS,`);
    lines.push(`    dda_matrix: ${safeId}_MATRIX,`);
    lines.push(`    exponents: ${safeId}_EXPONENTS,`);
    lines.push(`    error_values: ${safeId}_ERRORS,`);
    lines.push(`};`);
    lines.push(``);
  }

  // All variants array
  const variantIds = variantsToExport.map(
    (v) => `&${rustIdentifier(v.variant_id)}`,
  );
  lines.push(
    `const ALL_VARIANTS: &[&DDAVariant] = &[${variantIds.join(", ")}];`,
  );
  lines.push(``);

  // --- Section 3: Window indices ---
  if (
    result.results.window_indices &&
    result.results.window_indices.length > 0
  ) {
    const indices = result.results.window_indices.map((n) =>
      formatRustFloat(n),
    );
    lines.push(`const WINDOW_INDICES: &[f64] = &[${indices.join(", ")}];`);
  } else {
    const firstVariant = variantsToExport[0];
    const firstChannel = firstVariant
      ? Object.keys(firstVariant.dda_matrix)[0]
      : undefined;
    const numWindows =
      firstVariant && firstChannel
        ? (firstVariant.dda_matrix[firstChannel]?.length ?? 0)
        : 0;
    const indices: string[] = [];
    for (let i = 0; i < numWindows; i++) {
      indices.push(`${i * windowStep}.0`);
    }
    lines.push(`const WINDOW_INDICES: &[f64] = &[${indices.join(", ")}];`);
  }
  lines.push(``);

  // --- Section 4: Main ---
  lines.push(`// ${"=".repeat(70)}`);
  lines.push(`// Main`);
  lines.push(`// ${"=".repeat(70)}`);
  lines.push(``);
  lines.push(`fn main() {`);
  lines.push(`    println!("DDA Analysis: {}", FILE_PATH);`);
  lines.push(`    println!("Channels: {}", CHANNELS.join(", "));`);
  lines.push(
    `    println!("Parameters: window_length={}, window_step={}", WINDOW_LENGTH, WINDOW_STEP);`,
  );
  lines.push(`    println!("Delays: {:?}", DELAYS);`);
  lines.push(`    println!();`);
  lines.push(``);
  lines.push(`    if ALL_VARIANTS.is_empty() {`);
  lines.push(
    `        println!("Warning: No variant results embedded. The analysis may not have completed,");`,
  );
  lines.push(
    `        println!("or matrix data was not yet loaded when the export was created.");`,
  );
  lines.push(`        return;`);
  lines.push(`    }`);
  lines.push(``);
  lines.push(`    for variant in ALL_VARIANTS {`);
  lines.push(`        let n_channels = variant.channels.len();`);
  lines.push(
    `        let n_windows = variant.dda_matrix.first().map_or(0, |c| c.len());`,
  );
  lines.push(`        println!("  {} ({}): {} channels x {} windows",`);
  lines.push(
    `            variant.variant_id, variant.variant_name, n_channels, n_windows);`,
  );
  lines.push(`        for &(ch, exp) in variant.exponents {`);
  lines.push(`            println!("    {}: exponent = {:.4}", ch, exp);`);
  lines.push(`        }`);
  lines.push(`    }`);
  lines.push(`}`);

  return lines.join("\n");
}

export function getDefaultRustFilename(result: DDAResult): string {
  const timestamp = new Date(result.created_at)
    .toISOString()
    .replace(/[:.]/g, "-")
    .slice(0, 19);
  const fileName = result.name || result.id.slice(0, 8);
  return `dda_${fileName}_reproduce_${timestamp}.rs`;
}

function rustString(s: string): string {
  return `"${s.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}

function rustIdentifier(id: string): string {
  return id
    .toUpperCase()
    .replace(/[^A-Z0-9_]/g, "_")
    .replace(/^(\d)/, "V$1");
}

function formatRustFloat(n: number): string {
  const s = n.toPrecision(8);
  return s.includes(".") || s.includes("e") ? s : s + ".0";
}
